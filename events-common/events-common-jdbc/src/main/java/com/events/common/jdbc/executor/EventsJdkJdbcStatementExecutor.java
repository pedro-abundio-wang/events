package com.events.common.jdbc.executor;

import com.events.common.jdbc.exception.EventsDuplicateKeyException;
import com.events.common.jdbc.exception.EventsSqlException;

import java.sql.*;
import java.util.*;
import java.util.function.Supplier;

public class EventsJdkJdbcStatementExecutor implements EventsJdbcStatementExecutor {

  private static final Set<Integer> DUPLICATE_KEY_ERROR_CODES =
      new HashSet<>(
          Arrays.asList(
              1062, // MySQL
              23505, // PostgreSQL
              23001 // H2
              ));

  private final Supplier<Connection> connectionProvider;

  public EventsJdkJdbcStatementExecutor(Supplier<Connection> connectionProvider) {
    this.connectionProvider = connectionProvider;
  }

  @Override
  public long insertAndReturnAutoGeneratedId(String sql, String idColumn, Object... params) {
    Connection connection = connectionProvider.get();
    try (PreparedStatement preparedStatement =
        connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {
      for (int i = 1; i <= params.length; i++) {
        preparedStatement.setObject(i, params[i - 1]);
      }
      preparedStatement.executeUpdate();
      try (ResultSet generatedKeys = preparedStatement.getGeneratedKeys()) {
        if (generatedKeys.next()) {
          if (generatedKeys.getMetaData().getColumnCount() == 1) {
            // generate id can have different name than column (GENERATED_ID for mysql)
            return generatedKeys.getLong(1);
          }
          // contains all columns for postgresql
          return generatedKeys.getLong(idColumn);
        } else {
          throw new EventsSqlException("Id was not generated");
        }
      }
    } catch (SQLException e) {
      handleSqlUpdateException(e);
      return -1; // should not be here
    }
  }

  @Override
  public int update(String sql, Object... params) {
    Connection connection = connectionProvider.get();
    try (PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
      for (int i = 1; i <= params.length; i++) {
        preparedStatement.setObject(i, params[i - 1]);
      }
      return preparedStatement.executeUpdate();
    } catch (SQLException e) {
      handleSqlUpdateException(e);
      return -1; // should not be here
    }
  }

  @Override
  public <T> List<T> query(String sql, EventsRowMapper<T> eventsRowMapper, Object... params) {
    Connection connection = connectionProvider.get();
    try (PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
      for (int i = 1; i <= params.length; i++) {
        preparedStatement.setObject(i, params[i - 1]);
      }
      ResultSet rs = preparedStatement.executeQuery();
      List<T> result = new ArrayList<>();
      int rowNum = 0;
      while (rs.next()) {
        result.add(eventsRowMapper.mapRow(rs, rowNum++));
      }
      return result;
    } catch (SQLException e) {
      throw new EventsSqlException(e);
    }
  }

  @Override
  public List<Map<String, Object>> queryForList(String sql, Object... params) {
    Connection connection = connectionProvider.get();
    try (PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
      for (int i = 1; i <= params.length; i++) {
        preparedStatement.setObject(i, params[i - 1]);
      }
      ResultSet rs = preparedStatement.executeQuery();
      List<Map<String, Object>> result = new ArrayList<>();
      while (rs.next()) {
        Map<String, Object> row = new HashMap<>();
        for (int i = 1; i <= rs.getMetaData().getColumnCount(); i++) {
          row.put(rs.getMetaData().getColumnName(i), rs.getObject(i));
        }
        result.add(row);
      }
      return result;
    } catch (SQLException e) {
      throw new EventsSqlException(e);
    }
  }

  private void handleSqlUpdateException(SQLException e) {
    Optional<Integer> additionalErrorCode = Optional.empty();
    // Workaround for postgresql, where e.getErrorCode() is 0
    try {
      additionalErrorCode = Optional.of(Integer.parseInt(e.getSQLState()));
    } catch (NumberFormatException nfe) {
      // ignore
    }
    if (DUPLICATE_KEY_ERROR_CODES.contains(e.getErrorCode())
        || additionalErrorCode.map(DUPLICATE_KEY_ERROR_CODES::contains).orElse(false)) {
      throw new EventsDuplicateKeyException(e);
    }
    throw new EventsSqlException(e);
  }
}
